ifndef::imagesdir[:imagesdir: ../images]

// TODO: Konzepte, welche mehrere Komponenten betreffen (z.B. Schnittstellen, Datenmodell, Testing, Sicherheit) beschreiben.
// Hinweise:
// - Hier die proprietäre Schnittstelle zwischen LoggerComponent und LoggerServer dokumentieren.
// - Hier die Teststrategie dokumentieren (ca. ½ A4-Seite):
//   - Auf welchem Level (System, Komponente, Unit) wird welche Funktionalität getestet mit Begründung der Wahl.
//   - Welche Funktionalität wird automatisch getestet und welche manuell mit Begründung der Wahl.
//   - Welche Funktionalität wird nicht getestet mit Begründung, warum dies kein Problem ist.
//   - Zusätzliche Informationen, z.B. ob und für welche Funktionalitäten Test-First eingesetzt wird mit Begründung.


[[section-concepts]]
== Querschnittsthemen

=== Gateway

==== Gateway Endpoints

POST http://IP/api/v1/stores/createdefault (leerer Body): erstellt 10 default stores mit zufälliger Store ID.
POST http://IP/api/v1/stores/create (leerer Body): erstellt 1 stores mit zufälliger Store ID.
GET http://IP/api/v1/stores/: gibt alle Stores zurück.

=== Benutzerrechte und Rollen

==== System Rights

* user.crud_all
* customer.crud_all
* customer.crud_nodelete
* order.crud_all
* store.warehouse
* store.status
* store.all
* logs.read

==== User Roles with System Rights

* sys_admin
** user.crud_all
** customer.crud_all
** order.crud_all
** store.all
** logs.read
* sales_personell
** customer.crud_nodelete
** order.crud_all
* data_typist
** store.warehouse
* store_manager
** customer.crud_all
** order.crud_all
** store.status
** logs.read

=== Nachrichten zwischen den einzelnen Services

Die Este bezeichnung ist jeweils der Microservice, an den die Nachricht geschickt wird.
Zum Beispiel `ORDER_RECEIVE_VALIDITY` wird and den Microservice Order gesendet.

ORDER_RECEIVE_VALIDITY = "order.receive-validity";
OrderReceiveValidity(UUID idOrder, boolean valid, Map<Integer, Integer> francsPerUnit, Map<Integer, Integer> centimesPerUnit)

ORDER_RECEIVE = "order.receive";
GatewayOrderReceive(Map<Integer, Integer> articles, UUID storeId, UUID customerId, UUID employeeId)

ORDER_CUSTOMER_VALIDITY = "order.customer-validity";
OrderCustomerValidity(UUID orderId, boolean exists)

ORDER_UPDATE = "order.update";
OrderUpdate(UUID id, List<Integer> articles, boolean storeValid)

ORDER_CANCEL = "order.cancel";
OrderCancel(UUID orderId)

ORDER_CONFIRMATION_GET = "order.confirmation.get";
OrderConfirmationRequest(UUID orderId)

ARTICLES_CHECK_VALIDITY = "articles.check-validity";
ArticleCheckValidity(UUID orderId, Map<Integer, Integer> articles, UUID employeeId)

LOG = "logs.new";
LogMessage(String source, long timestamp, UUID userId, String eventType, UUID objUuid, String message)

STORE_REQUEST_ARTICLES = "store.request-articles";
StoreRequestArticles(UUID orderId, UUID employeeId, UUID storeId, Map<Integer, Integer> articles)

CUSTOMER_VALIDATE = "customer.validate";
CustomerValidate(UUID customerId, UUID employeeId, UUID orderId)

STORE_ORDER_READY = "store.order-ready";
StoreOrderReady(UUID orderId, UUID storeId)

STORE_ORDER_CANCELLED = "store.order-cancelled";
StoreOrderCancelled(UUID orderId, UUID storeId)

INVOICE_CREATE = "invoice.create";
InvoiceCreate(UUID orderId, UUID customerId, UUID employeeId, UUID storeId, Map<Integer, Integer> articlesCount, Map<Integer, String> articlesPrices, String totalPrice)

==== Store Management

store.request-articles
store.inventory-update
store.order-ready
store.status
store.create (leere message)
store.create-default (leere message)
stores.get

==== Article Registry

article.create

* name : String
* price : int
* description : String

article.delete

* id : Integer

articles.checkValidity

* orderId : int
* Articles : Map <idArticle : Integer, count : Integer>

==== Central Warehouse

central-warehouse.request

* articles : Map <idArticle : Integer, count : Integer>
* storeId: UUID
* orderId: UUID

central-warehouse.complete

* orderId: UUID
* storeId: UUID



==== Authentication & User Management

==== Logs

logs.new

* source : String
* timestamp : long
* userId : UUID
* eventType : String
* objUuid : UUID
* message : String

logs.get

* id : UUID (optional)

logs.filter

* source : String
* userId : String
* eventType : String
* objUuid : String
* direction : String ("asc" or "desc")
* amount : int

UUIDs in a filter are currently String to do .isEmpty() checks rather than null

==== Order

order.create

* id: UUID
* articles: Map <idArticle : Integer, count : Integer>
* date : Date
* status: Enum
* storeId: Integer
* employeeId: UUID
* customerId: UUID

order.validate

* oderId : int
* validity : true

==== Customer Management

customer.create

* firstname : String
* lastname : String

customer.get

* UUID (Optional)

customer.validate

* UUID

customer.update

* firstname : String (Optional)
* lastname : String (Optional)

customer.delete

* UUID

(customer.validate und customer.delete soll einfach das UUID haben, keine Wrapper-Klasse)

==== Accounting

invoice.create

* orderId : UUID
* customerId : UUID
* employeeId : UUID
* storeId : UUID
* Artikel (Format TBD)
* Preise (Format TBD)
* Gesamtpreis : int

invoice.get
* customerId : UUID
* invoiceId : UUID

paymentwarning.get
* customerId : UUID

=== DB Einträge

*TBD Json Prototypen bei Order, store management*

Order (Order)

* id: Integer
* valid : boolean
* articles: Map <idArticle : Integer, count : Integer>
* date : Date
* status: Enum
* storeId: Integer
* employeeId: UUID
* customerId: UUID

vielleicht nach 24 stunden checken ob es noch invalid gibt und checkArticleValidity() ereut senden

Customer (Customer Management)

* id : UUID
* firstname : String
* lastname : String

Article (Article Registry)

* id : int
* name : String
* price : int
* description : String
* unregistered : boolean

Sortiment (Store Management)

* articleId : int
* actualCount : int
* minCount : int
* countAfterRefill : int

Store (Store Management)

* id: UUID
* articleList : List<StoreArticle>
* openOrders : List<Order>

LogEntry (Log)

* id : UUID
* source : String
* timestamp : long
* userId : UUID
* eventType : String
* objUuid : UUID
* message : String

==== Central Warehouse Service:
These are the tables and fields of the central_warehouse MySQL Database

===== Table warehouseOrder
* id : int
* uuid : varchar(50)
* store_id : varchar(50)
* customer_order_id : varchar(50)
* cancelled : bit

===== Table warehouseOrderArticle
* warehouse_order : int (fk to warehouseOrder.id)
* article : int
* count :int
* fulfilled : int
* next_delivery_date : Date

=== Testkonzept
Für dieses Projekt wurde kein Testkonzept erstellt. Weder zu Beginn, noch in der Definition of Done.

==== Was getestet wird
Mit dieser Grundlage sind die Microservices unterschiedlich getestet. Alle Microservices ausser dem Gateway und Auth Service enthalten mindestens Unit Tests. Die Microservices mit zentraler Business Logic sind mit hoher Coverage getestet worden und nutzen Stubs, Mocks oder Fakes für Integrationstests (Order Service, Article Registry Service, Store Management Service, Log Service). Der Central Warehouse Service und Customer Management Service nutzen Testcontainer für Persistenztests mit den jeweiligen Datenbanken.

Die meisten Microservices wurden zusätzlich manuell mit Messages über den Bus oder über den Gateway-Service mit Curl oder Postman getestet, wobei Antworten, Logs und Datenbank-Einträge auf erwartete Werte geprüft wurden.

Systemtests werden komplett manuell durchgeführt. Für das Testen wird eine Liste an https requests nach und nach abgearbeitet.