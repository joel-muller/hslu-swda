ifndef::imagesdir[:imagesdir: ../images]

// TODO: Konzepte, welche mehrere Komponenten betreffen (z.B. Schnittstellen, Datenmodell, Testing, Sicherheit) beschreiben.
// Hinweise:
// - Hier die proprietäre Schnittstelle zwischen LoggerComponent und LoggerServer dokumentieren.
// - Hier die Teststrategie dokumentieren (ca. ½ A4-Seite):
//   - Auf welchem Level (System, Komponente, Unit) wird welche Funktionalität getestet mit Begründung der Wahl.
//   - Welche Funktionalität wird automatisch getestet und welche manuell mit Begründung der Wahl.
//   - Welche Funktionalität wird nicht getestet mit Begründung, warum dies kein Problem ist.
//   - Zusätzliche Informationen, z.B. ob und für welche Funktionalitäten Test-First eingesetzt wird mit Begründung.


[[section-concepts]]
== Querschnittsthemen

=== Gateway

==== Gateway Endpoints

POST http://IP/api/v1/stores/createdefault (leerer Body): erstellt 10 default stores mit zufälliger Store ID.
POST http://IP/api/v1/stores/create (leerer Body): erstellt 1 stores mit zufälliger Store ID.
GET http://IP/api/v1/stores/: gibt alle Stores zurück.

=== Benutzerrechte und Rollen

==== System Rights

* user.crud_all
* customer.crud_all
* customer.crud_nodelete
* order.crud_all
* store.warehouse
* store.status
* store.all
* logs.read

==== User Roles with System Rights

* sys_admin
** user.crud_all
** customer.crud_all
** order.crud_all
** store.all
** logs.read
* sales_personell
** customer.crud_nodelete
** order.crud_all
* data_typist
** store.warehouse
* store_manager
** customer.crud_all
** order.crud_all
** store.status
** logs.read

=== Nachrichten zwischen den einzelnen Services

==== Store Management

store.request-articles
store.inventory-update
store.order-ready
store.status
store.create (leere message)
store.create-default (leere message)
stores.get

==== Article Registry

article.create

* name : String
* price : int
* description : String

article.delete

* id : Integer

articles.checkValidity

* orderId : int
* Articles : Map <idArticle : Integer, count : Integer>

==== Central Warehouse

central-warehouse.request

* articles : Map <idArticle : Integer, count : Integer>
* storeId: UUID
* orderId: UUID

central-warehouse.complete

* orderId: UUID
* storeId: UUID



==== Authentication & User Management

==== Logs

logs.new

* source : String
* timestamp : long
* userId : UUID
* eventType : String
* objUuid : UUID
* message : String

logs.get

* id : UUID (optional)

logs.filter

* source : String
* userId : String
* eventType : String
* objUuid : String
* direction : String ("asc" or "desc")
* amount : int

UUIDs in a filter are currently String to do .isEmpty() checks rather than null

==== Order

order.create

* id: UUID
* articles: Map <idArticle : Integer, count : Integer>
* date : Date
* status: Enum
* storeId: Integer
* employeeId: UUID
* customerId: UUID

order.validate

* oderId : int
* validity : true

==== Customer Management

customer.create

* firstname : String
* lastname : String

customer.get

* UUID (Optional)

customer.validate

* UUID

customer.update

* firstname : String (Optional)
* lastname : String (Optional)

customer.delete

* UUID

(customer.validate und customer.delete soll einfach das UUID haben, keine Wrapper-Klasse)

==== Accounting

invoice.create

* orderId : UUID
* customerId : UUID
* employeeId : UUID
* storeId : UUID
* Artikel (Format TBD)
* Preise (Format TBD)
* Gesamtpreis : int

invoice.get
* customerId : UUID
* invoiceId : UUID

paymentwarning.get
* customerId : UUID

=== DB Einträge

*TBD Json Prototypen bei Order, store management*

Order (Order)

* id: Integer
* valid : boolean
* articles: Map <idArticle : Integer, count : Integer>
* date : Date
* status: Enum
* storeId: Integer
* employeeId: UUID
* customerId: UUID

vielleicht nach 24 stunden checken ob es noch invalid gibt und checkArticleValidity() ereut senden

Customer (Customer Management)

* id : UUID
* firstname : String
* lastname : String

Article (Article Registry)

* id : int
* name : String
* price : int
* description : String
* unregistered : boolean

Sortiment (Store Management)

* articleId : int
* actualCount : int
* minCount : int
* countAfterRefill : int

Store (Store Management)

* id: UUID
* articleList : List<StoreArticle>
* openOrders : List<Order>

LogEntry (Log)

* id : UUID
* source : String
* timestamp : long
* userId : UUID
* eventType : String
* objUuid : UUID
* message : String

=== Testkonzept
Für dieses Projekt wurde kein Testkonzept erstellt. Weder zu Beginn, noch in der Definition of Done.

==== Was getestet wird
Mit dieser Grundlage sind die Microservices unterschiedlich getestet. Alle Microservices ausser dem Gateway und Auth Service enthalten mindestens Unit Tests. Die Microservices mit zentraker Business Logic sind mit hoher Coverage getestet worden und nutzen Stubs, Mocks oder Fakes für Integrationstests (Order Service, Article Registry Service, Store Management Service, Log Service). Der Central Warehouse Service und Customer Management Service nutzen Testcontainer für Persistenztests mit den jeweiligen Datenbanken.

Die meisten Microservices wurden zusätzlich manuell mit Messages über den Bus oder über den Gateway-Service mit Curl oder Postman getestet, wobei Antworten, Logs und Datenbank-Einträge auf erwartete Werte geprüft wurden.

Systemtests werden komplett manuell durchgeführt anhand einer Liste an https requests, die nach und nach abgearbeitet wird.


=== Reflexion Testkonzept
==== Weshalb wurde kein konsistenter Fokus auf Testing gesetzt?

Das Team hat die Sprints mit vielen und grossen Backlog Items gefüllt. Ausserdem hat es den Fokus auf das Sprint-Review gesetzt. Für das Review war einzig relevant, was auf der Produktivumgebung erfolgreich läuft. Die für die Backlog items geplante Zeit wurde oft überschritten, um die Funktionalität zeigen zu können. Ein Teil davon ist sicher auf die fehlende Erfahrung mit der MoM zurückzuführen. Dafür machte das Team Abstriche beim Testing und auch das Sprint Planning litt darunter, was zur Wiederholung der Problematik führte.

Die Grösse der Microservices war bei der Entwicklung eine grosse Hilfe. Denn immerhin waren Fehler bei der Verarbeitung innerhalb eines einzigen Services zu suchen.

==== Wie wäre es anders gegangen?
Es wäre definitiv möglich gewesen, den Fokus mehr auf Testing zu setzen. Dafür hätte das Team als Erstes den Sprint backlog verkleinern müssen und sich danach auf die wichtigsten Epics fokussieren sollen. Das hätte Druck genommen, viel am Sprint-Review zeigen zu müssen. Zudem hätte es mehr Luft gelassen für einen Test-First Approach sowie ausführlicheres Testing. Eine klare Definition of Done, sowie eine Priorisierung deren Einhaltung hätte ebenfalls geholfen.