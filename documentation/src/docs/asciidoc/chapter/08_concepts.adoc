ifndef::imagesdir[:imagesdir: ../images]

// TODO: Konzepte, welche mehrere Komponenten betreffen (z.B. Schnittstellen, Datenmodell, Testing, Sicherheit) beschreiben.
// Hinweise:
// - Hier die proprietäre Schnittstelle zwischen LoggerComponent und LoggerServer dokumentieren.
// - Hier die Teststrategie dokumentieren (ca. ½ A4-Seite):
//   - Auf welchem Level (System, Komponente, Unit) wird welche Funktionalität getestet mit Begründung der Wahl.
//   - Welche Funktionalität wird automatisch getestet und welche manuell mit Begründung der Wahl.
//   - Welche Funktionalität wird nicht getestet mit Begründung, warum dies kein Problem ist.
//   - Zusätzliche Informationen, z.B. ob und für welche Funktionalitäten Test-First eingesetzt wird mit Begründung.


[[section-concepts]]
== Querschnittsthemen

=== Gateway

==== Gateway Endpoints

POST http://IP/api/v1/stores/createdefault (leerer Body): erstellt 10 default stores mit zufälliger Store ID.
POST http://IP/api/v1/stores/create (leerer Body): erstellt 1 stores mit zufälliger Store ID.
GET http://IP/api/v1/stores/: gibt alle Stores zurück.

=== Benutzerrechte und Rollen

==== System Rights

* user.crud_all
* customer.crud_all
* customer.crud_nodelete
* order.crud_all
* store.warehouse
* store.status
* store.all
* logs.read

==== User Roles with System Rights

* sys_admin
** user.crud_all
** customer.crud_all
** order.crud_all
** store.all
** logs.read
* sales_personell
** customer.crud_nodelete
** order.crud_all
* data_typist
** store.warehouse
* store_manager
** customer.crud_all
** order.crud_all
** store.status
** logs.read

=== Nachrichten zwischen den einzelnen Services

Die Este bezeichnung ist jeweils der Microservice, an den die Nachricht geschickt wird (`IngoingMessage`).
Zum Beispiel `ORDER_RECEIVE_VALIDITY` wird and den Microservice Order gesendet.

==== Order Service

[source,txt]
----
ORDER_RECEIVE_VALIDITY = "order.receive-validity"
OrderReceiveValidity(UUID idOrder, boolean valid, Map<Integer, Integer> francsPerUnit, Map<Integer, Integer> centimesPerUnit)
----

[source,txt]
----
ORDER_RECEIVE = "order.receive"
GatewayOrderReceive(Map<Integer, Integer> articles, UUID storeId, UUID customerId, UUID employeeId)
----

[source,txt]
----
ORDER_CUSTOMER_VALIDITY = "order.customer-validity"
OrderCustomerValidity(UUID orderId, boolean exists)
----

[source,txt]
----
ORDER_UPDATE = "order.update"
OrderUpdate(UUID id, List<Integer> articles, boolean storeValid)
----

[source,txt]
----
ORDER_CANCEL = "order.cancel"
OrderCancel(UUID orderId)
----

[source,txt]
----
ORDER_CONFIRMATION_GET = "order.confirmation.get"
OrderConfirmationRequest(UUID orderId)
----

==== Store Management Service

[source,txt]
----
STORE_REQUEST_ARTICLES = "store.request-articles"
StoreRequestArticles(UUID orderId, UUID employeeId, UUID storeId, Map<Integer, Integer> articles)
----

[source,txt]
----
STORE_INVENTORY_UPDATE = "store.inventory-update"
StoreInventoryUpdate(Map<Integer, Integer> articles, UUID orderId, UUID storeId)
----

[source,txt]
----
STORE_ORDER_READY = "store.order-ready"
StoreOrderReady(UUID orderId, UUID storeId)
----

[source,txt]
----
STORE_ORDER_CANCELLED = "store.order-cancelled"
StoreOrderCancelled(UUID orderId, UUID storeId)
----

[source,txt]
----
STORE_INTERNAL_ORDER = "store.internal-order"
StoreInternalOrder(UUID storeId, Map<Integer, Integer> articles)
----

[source,txt]
----
STORE_CREATION = "store.create-create"
StoreCreation(boolean addDefaultArticle)
----

==== Customer Service

[source,txt]
----
CUSTOMER_VALIDATE = "customer.validate"
CustomerValidate(UUID customerId, UUID employeeId, UUID orderId)
----

==== Accounting Service

[source,txt]
----
INVOICE_CREATE = "invoice.create"
InvoiceCreate(UUID orderId, UUID customerId, UUID employeeId, UUID storeId, Map<Integer, Integer> articlesCount, Map<Integer, String> articlesPrices, String totalPrice)
----

==== Central Warehouse Service

[source,txt]
----
WAREHOUSE_REQUEST = "central-warehouse.request"
WarehouseRequest(UUID orderId, UUID storeId, Map<Integer, Integer> articles)
----

==== Article Registry Service

[source,txt]
----
ARTICLES_CHECK_VALIDITY = "articles.check-validity"
ArticleCheckValidity(UUID orderId, Map<Integer, Integer> articles, UUID employeeId)
----

==== Log Service

[source,txt]
----
LOG = "logs.new"
LogMessage(String source, long timestamp, UUID userId, String eventType, UUID objUuid, String message)
----

==== Central Warehouse (TODO Make code format)

central-warehouse.request

* articles : Map <idArticle : Integer, count : Integer>
* storeId: UUID
* orderId: UUID

central-warehouse.complete

* orderId: UUID
* storeId: UUID



==== Authentication & User Management (TODO Make code format)

==== Logs (TODO Make code format)

logs.new

* source : String
* timestamp : long
* userId : UUID
* eventType : String
* objUuid : UUID
* message : String

logs.get

* id : UUID (optional)

logs.filter

* source : String
* userId : String
* eventType : String
* objUuid : String
* direction : String ("asc" or "desc")
* amount : int

UUIDs in a filter are currently String to do .isEmpty() checks rather than null


==== Customer Management (TODO Make code format)

customer.create

* firstname : String
* lastname : String

customer.get

* UUID (Optional)

customer.validate

* UUID

customer.update

* firstname : String (Optional)
* lastname : String (Optional)

customer.delete

* UUID

(customer.validate und customer.delete soll einfach das UUID haben, keine Wrapper-Klasse)

==== Accounting (TODO Make code format)

invoice.create

* orderId : UUID
* customerId : UUID
* employeeId : UUID
* storeId : UUID
* Artikel (Format TBD)
* Preise (Format TBD)
* Gesamtpreis : int

invoice.get
* customerId : UUID
* invoiceId : UUID

paymentwarning.get
* customerId : UUID

=== DB Einträge

*TBD Json Prototypen bei Order, store management*

==== Order Service

[source,txt]
----
{
    _id: UUID("76895c82acd345909c007c24a70907f4"),
    _t: 'DBOrder',
    articles: [
        {
            _t: 'DBArticle',
            id: 100016,
            count: 5,
            delivered: false,
            francs: 17,
            centimes: 35
        }
    ],
    date: ISODate('2024-12-21T11:01:47.389Z'),
    storeId: UUID("5788b73987ca416b804adb70f85d1f8c"),
    customerId: UUID("1601ce09a90747ad86657b4705796c69"),
    employeeId: UUID("f9e3d9094c9443e1b9722ad519ebcfb9"),
    stateEnum: 2,
    cancelled: false
}
----

States können sein:
* STORED(1)
* ARTICLE_VALIDATED(2)
* CUSTOMER_VALID(3)
* READY(4)

==== Store Management Service

[source,txt]
----
{
    _id: UUID("5788b73987ca416b804adb70f85d1f8c"),
    _t: 'DBStore',
    articleList: [
        {
            _t: 'DBStoreArticle',
            id: 100054,
            actualQuantity: 100,
            minimumQuantity: 10,
            refillCount: 100
        }
    ],
    openOrders: [
        {
            _t: 'DBOrder',
            id: UUID("76895c82acd345909c007c24a70907f4"),
            articleOrderedList: [
                {
                    _t: 'DBOrderArticle',
                    id: 100016,
                    count: 5,
                    ready: false
                }
            ]
        }
    ]
}
----

==== Customer (Customer Management)

* id : UUID
* firstname : String
* lastname : String

Article (Article Registry)

* id : int
* name : String
* price : int
* description : String
* unregistered : boolean

Sortiment (Store Management)

* articleId : int
* actualCount : int
* minCount : int
* countAfterRefill : int

Store (Store Management)

* id: UUID
* articleList : List<StoreArticle>
* openOrders : List<Order>

LogEntry (Log)

* id : UUID
* source : String
* timestamp : long
* userId : UUID
* eventType : String
* objUuid : UUID
* message : String

==== Central Warehouse Service:
These are the tables and fields of the central_warehouse MySQL Database

===== Table warehouseOrder
* id : int
* uuid : varchar(50)
* store_id : varchar(50)
* customer_order_id : varchar(50)
* cancelled : bit

===== Table warehouseOrderArticle
* warehouse_order : int (fk to warehouseOrder.id)
* article : int
* count :int
* fulfilled : int
* next_delivery_date : Date

=== Testkonzept
Für dieses Projekt wurde kein Testkonzept erstellt. Weder zu Beginn, noch in der Definition of Done.

==== Was getestet wird
Mit dieser Grundlage sind die Microservices unterschiedlich getestet. Alle Microservices ausser dem Gateway und Auth Service enthalten mindestens Unit Tests. Die Microservices mit zentraler Business Logic sind mit hoher Coverage getestet worden und nutzen Stubs, Mocks oder Fakes für Integrationstests (Order Service, Article Registry Service, Store Management Service, Log Service). Der Central Warehouse Service und Customer Management Service nutzen Testcontainer für Persistenztests mit den jeweiligen Datenbanken.

Die meisten Microservices wurden zusätzlich manuell mit Messages über den Bus oder über den Gateway-Service mit Curl oder Postman getestet, wobei Antworten, Logs und Datenbank-Einträge auf erwartete Werte geprüft wurden.

Systemtests werden komplett manuell durchgeführt. Für das Testen wird eine Liste an https requests nach und nach abgearbeitet.