ifndef::imagesdir[:imagesdir: ../images]

// TODO: Konzepte, welche mehrere Komponenten betreffen (z.B. Schnittstellen, Datenmodell, Testing, Sicherheit) beschreiben.
// Hinweise:
// - Hier die proprietäre Schnittstelle zwischen LoggerComponent und LoggerServer dokumentieren.
// - Hier die Teststrategie dokumentieren (ca. ½ A4-Seite):
//   - Auf welchem Level (System, Komponente, Unit) wird welche Funktionalität getestet mit Begründung der Wahl.
//   - Welche Funktionalität wird automatisch getestet und welche manuell mit Begründung der Wahl.
//   - Welche Funktionalität wird nicht getestet mit Begründung, warum dies kein Problem ist.
//   - Zusätzliche Informationen, z.B. ob und für welche Funktionalitäten Test-First eingesetzt wird mit Begründung.


[[section-concepts]]
== Querschnittsthemen

=== Gateway

==== Gateway Endpoints

POST http://IP/api/v1/stores/createdefault (leerer Body): erstellt 10 default stores mit zufälliger Store ID.
POST http://IP/api/v1/stores/create (leerer Body): erstellt 1 stores mit zufälliger Store ID.
GET http://IP/api/v1/stores/: gibt alle Stores zurück.

=== Benutzerrechte und Rollen

==== System Rights

* user.crud_all
* customer.crud_all
* customer.crud_nodelete
* order.crud_all
* store.warehouse
* store.status
* store.all
* logs.read

==== User Roles with System Rights

* sys_admin
** user.crud_all
** customer.crud_all
** order.crud_all
** store.all
** logs.read
* sales_personell
** customer.crud_nodelete
** order.crud_all
* data_typist
** store.warehouse
* store_manager
** customer.crud_all
** order.crud_all
** store.status
** logs.read

=== Nachrichten zwischen den einzelnen Services

==== Store Management

store.request-articles
store.inventory-update
store.order-ready
store.status
store.create (leere message)
store.create-default (leere message)
stores.get

==== Article Registry

article.create

* name : String
* price : int
* description : String

article.delete

* id : Integer

articles.checkValidity

* orderId : int
* Articles : Map <idArticle : Integer, count : Integer>

==== Central Warehouse

central-warehouse.request

* articles : Map <idArticle : Integer, count : Integer>
* storeId: UUID
* orderId: UUID

central-warehouse.complete

* orderId: UUID
* storeId: UUID



==== Authentication & User Management

==== Logs

logs.new

* source : String
* timestamp : long
* userId : UUID
* eventType : String
* objUuid : UUID
* message : String

logs.get

* id : UUID (optional)

logs.filter

* source : String
* userId : String
* eventType : String
* objUuid : String
* direction : String ("asc" or "desc")
* amount : int

UUIDs in a filter are currently String to do .isEmpty() checks rather than null

==== Order

order.create

* id: UUID
* articles: Map <idArticle : Integer, count : Integer>
* date : Date
* status: Enum
* storeId: Integer
* employeeId: UUID
* customerId: UUID

order.validate

* oderId : int
* validity : true

==== Customer Management

customer.create

* firstname : String
* lastname : String

customer.get

* UUID (Optional)

customer.validate

* UUID

customer.update

* firstname : String (Optional)
* lastname : String (Optional)

customer.delete

* UUID

(customer.validate und customer.delete soll einfach das UUID haben, keine Wrapper-Klasse)

==== Accounting

invoice.create

* orderId : UUID
* customerId : UUID
* employeeId : UUID
* storeId : UUID
* Artikel (Format TBD)
* Preise (Format TBD)
* Gesamtpreis : int

invoice.get
* customerId : UUID
* invoiceId : UUID

paymentwarning.get
* customerId : UUID

=== DB Einträge

*TBD Json Prototypen bei Order, store management*

Order (Order)

* id: Integer
* valid : boolean
* articles: Map <idArticle : Integer, count : Integer>
* date : Date
* status: Enum
* storeId: Integer
* employeeId: UUID
* customerId: UUID

vielleicht nach 24 stunden checken ob es noch invalid gibt und checkArticleValidity() ereut senden

Customer (Customer Management)

* id : UUID
* firstname : String
* lastname : String

Article (Article Registry)

* id : int
* name : String
* price : int
* description : String
* unregistered : boolean

Sortiment (Store Management)

* articleId : int
* actualCount : int
* minCount : int
* countAfterRefill : int

Store (Store Management)

* id: UUID
* articleList : List<StoreArticle>
* openOrders : List<Order>

LogEntry (Log)

* id : UUID
* source : String
* timestamp : long
* userId : UUID
* eventType : String
* objUuid : UUID
* message : String

