ifndef::imagesdir[:imagesdir: ../images]

// TODO: Anhand von Datenflüssen beschreiben wie das zu entwickelnde System eingesetzt wird.
// Also Daten, welche Benutzer oder umgebende Systeme in das zu entwickelnde System einspeisen oder abgreifen.
// Diese Beschreibung wird oft von einem Diagramm unterstützt, Dieses Diagram ist in VSK pflicht!
// Hinweis: Hier Benutzerschnittstellen und externe Schnittstellen mit Version spezifizieren.

[[section-system-scope-and-context]]
== System Scope and Context

== Business Context

=== Kontextdiagramm

image::kontextdiagramm.png[Kontextdiagramm]

**<Diagram or Table>**

**<optionally: Explanation of external domain interfaces>**

=== Technical Context

**<Diagram or Table>**

**<optionally: Explanation of technical interfaces>**

**<Mapping Input/Output to Channels>**

=== Messages

Nicht sicher ob es ein eigener Header braucht oder nicht oder ob man es in die beiden anderen Header integrieren sollte

Jeder MS hat die messages die er bekommt gelisted

Prio Sprint 1: Order, customer Management, accounting

==== Gateway endpoints:

POST http://IP/api/v1/stores/createdefault (leerer Body): erstellt 10 default stores mit zufälliger Store ID.
POST http://IP/api/v1/stores/create (leerer Body): erstellt 1 stores mit zufälliger Store ID.
GET http://IP/api/v1/stores/: gibt alle Stores zurück. 

==== System Rights

* user.crud_all
* customer.crud_all
* customer.crud_nodelete
* order.crud_all
* store.warehouse
* store.status
* store.all
* logs.read

==== User Roles with System Rights

* sys_admin
** user.crud_all
** customer.crud_all
** order.crud_all
** store.all
** logs.read
* sales_personell
** customer.crud_nodelete
** order.crud_all
* data_typist
** store.warehouse
* store_manager
** customer.crud_all
** order.crud_all
** store.status
** logs.read

==== Store Management

store.request-articles
store.inventory-update
store.order-ready
store.status
store.create (leere message)
store.create-default (leere message)
stores.get
 
==== Article Registry

article.create

* name : String
* price : int
* description : String

article.delete

* id : Integer

articles.checkValidity

* orderId : int
* Articles : Map <idArticle : Integer, count : Integer>

==== Central Warehouse

central-warehouse.request

* articles : Map <idArticle : Integer, count : Integer>
* storeId: UUID
* orderId: UUID

central-warehouse.complete

* orderId: UUID
* storeId: UUID



==== Authentication & User Management

==== Logs

logs.new

* source : String
* timestamp : long
* userId : UUID
* eventType : String
* objUuid : UUID
* message : String

logs.get

* id : UUID (optional)

logs.filter

* source : String
* userId : String
* eventType : String
* objUuid : String
* direction : String ("asc" or "desc")
* amount : int

UUIDs in a filter are currently String to do .isEmpty() checks rather than null

==== Order

order.create

* id: UUID
* articles: Map <idArticle : Integer, count : Integer>
* date : Date
* status: Enum
* storeId: Integer
* employeeId: UUID
* customerId: UUID

order.validate

* oderId : int
* validity : true

==== Customer Management

customer.create

* firstname : String
* lastname : String

customer.get

* UUID (Optional)

customer.validate

* UUID

customer.update

* firstname : String (Optional)
* lastname : String (Optional)

customer.delete

* UUID

(customer.validate und customer.delete soll einfach das UUID haben, keine Wrapper-Klasse)

==== Accounting

invoice.create

* orderId : UUID
* customerId : UUID
* employeeId : UUID
* storeId : UUID
* Artikel (Format TBD)
* Preise (Format TBD)
* Gesamtpreis : int

invoice.get
* customerId : UUID
* invoiceId : UUID

paymentwarning.get
* customerId : UUID

=== DB Entries

Order (Order)

* id: Integer
* valid : boolean
* articles: Map <idArticle : Integer, count : Integer>
* date : Date
* status: Enum
* storeId: Integer
* employeeId: UUID
* customerId: UUID

vielleicht nach 24 stunden checken ob es noch invalid gibt und checkArticleValidity() ereut senden

Customer (Customer Management)

* id : UUID
* firstname : String
* lastname : String

Article (Article Registry)

* id : int
* name : String
* price : int
* description : String
* unregistered : boolean

Sortiment (Store Management)

* articleId : int
* actualCount : int
* minCount : int
* countAfterRefill : int

Store (Store Management)

* id: UUID
* articleList : List<StoreArticle>
* openOrders : List<Order>

LogEntry (Log)

* id : UUID
* source : String
* timestamp : long
* userId : UUID
* eventType : String
* objUuid : UUID
* message : String