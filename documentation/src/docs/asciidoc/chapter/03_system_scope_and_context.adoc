ifndef::imagesdir[:imagesdir: ../images]

// TODO: Anhand von Datenflüssen beschreiben wie das zu entwickelnde System eingesetzt wird.
// Also Daten, welche Benutzer oder umgebende Systeme in das zu entwickelnde System einspeisen oder abgreifen.
// Diese Beschreibung wird oft von einem Diagramm unterstützt, Dieses Diagram ist in VSK pflicht!
// Hinweis: Hier Benutzerschnittstellen und externe Schnittstellen mit Version spezifizieren.

[[section-system-scope-and-context]]
== System Scope and Context

=== Business Context

**<Diagram or Table>**

**<optionally: Explanation of external domain interfaces>**

=== Technical Context

**<Diagram or Table>**

**<optionally: Explanation of technical interfaces>**

**<Mapping Input/Output to Channels>**

=== Messages

Nicht sicher ob es ein eigener Header braucht oder nicht oder ob man es in die beiden anderen Header integrieren sollte

Jeder MS hat die messages die er bekommt gelisted

Prio Sprint 1: Order, customer Management, accounting

==== Store Management

inventory.update (auch für das Hinzufügen neuer Artikel/Einträge in die Inventory-Datenbank)

* store: String
* articleId : int
* minimuimQuantity: int
* actualQuantity: int


inventory.check

* store: String
* articleId : int


==== Article Registry

article.create

* name : String
* price : int
* description : String

article.delete

* id : Integer

articles.checkValidity

* orderId : int
* Articles : Map <idArticle : Integer, count : Integer>

==== Central Warehouse

warehouse.order

* articles : Map <idArticle : Integer, count : Integer>
* storeId: Integer
* customerOrderId: Integer

==== Authentication & User Management

==== Logs

logs.new

* source : String
* timestamp : long
* userId : UUID
* eventType : String
* objUuid : UUID
* message : String

logs.get

* id : UUID (optional)

logs.filter

* source : String
* userId : String
* eventType : String
* objUuid : String
* direction : String ("asc" or "desc")
* amount : int

UUIDs in a filter are currently String to do .isEmpty() checks rather than null

==== Order

order.create

* id: UUID
* articles: Map <idArticle : Integer, count : Integer>
* date : Date
* status: Enum
* storeId: Integer
* employeeId: UUID
* customerId: UUID

order.validate

* oderId : int
* validity : true

==== Customer Management

customer.create

* firstName : String
* lastName : String

customer.get

* UUID (Optional)

customer.validate

* UUID

(customer.validate soll einfach das UUID haben, keine Wrapper-Klasse)

==== Accounting

confirmation.create

* orderId : Integer
* customerId : Integer

=== DB Entries

Order (Order)

* id: Integer
* valid : boolean
* articles: Map <idArticle : Integer, count : Integer>
* date : Date
* status: Enum
* storeId: Integer
* employeeId: Integer
* customerId: Integer

vielleicht nach 24 stunden checken ob es noch invalid gibt und checkArticleValidity() ereut senden

Customer (Customer Management)

* id : Integer
* firstName : String
* lastName : String

Article (Article Registry)

* id : int
* name : String
* price : int
* description : String
* unregistered : boolean

Sortiment (Store Management)

* articleId : int
* actualCount : int
* minCount : int
* countAfterRefill : int

Store (Store Management)
